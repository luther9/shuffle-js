#!/usr/bin/env node

'use strict'

/*
A list is defined as either undefined or a 2-element Array where [1] is another
list.
*/

/*
  Return an iterator for the linked list.
*/
function* listIter(list) {
  while (list) {
    yield list[0]
    list = list[1]
  }
}

function* map(iter, func) {
  for (const item of iter) {
    yield func(item)
  }
}

/*
  Yield n items from iter. If iterator runs out of items, yield undefined.
*/
function* islice(iter, n) {
  for (let i = 0; i < n; ++i) {
    yield iter.next().value
  }
}

/*
Show all items in a string surrounded by parentheses.
*/
function iterString(iter) {
  let str = '('
  let first = true
  for (const item of iter) {
    if (first) {
      first = false
    } else {
      str += ' '
    }
    str += item
  }
  return str + ')'
}

const pileLetters = ['A', 'B']

/*
Yield numbers from 0 to infinity.
*/
function* count() {
  for (let i = 0;; ++i) {
    yield i
  }
}

/*
Yield numbers in the range [0,n).
*/
function range(n) {
  return islice(count(), n)
}

// Yield numbers in [0,n) in a random order.
function* randomIntStream(n) {
  let pool = [...range(n)]
  while (pool.length) {
    const i = Math.floor(Math.random() * pool.length)
    yield pool[i]
    pool = pool.slice(0, i).concat(pool.slice(i + 1))
  }
}

function deck(uniques, identicals) {
  const pool = randomIntStream(uniques + identicals.reduce((a, b) => a + b, 0))
  const d = [...islice(pool, uniques)]
  for (const n of identicals) {
    const more = [...islice(pool, n)]
    more.sort((a, b) => a - b)
    d.push(...more)
  }
  return d
}

function findChunkStart(pile, median, i) {
  for (; pile[i] > median; ++i) {}
  return i
}

function findChunkEnd(pile, i) {
  for (; i < pile.length && pile[i] === pile[i - 1] + 1; ++i) {}
  return i
}

/*
  Return the lowest number that will go to pile B.
*/
function getCutoff(pile) {
  const median = Math.min(...pile) + (pile.length - 1) / 2
  let loI = 0
  while (true) {
    loI = findChunkStart(pile, median, loI)
    let hiI = findChunkEnd(pile, loI + 1)
    const lo = pile[loI]
    const hi = pile[hiI - 1] + 1
    if (hi > median) {
      return median - lo < hi - median
	? lo
	: hi
    }
    loI = hiI
  }
}

function getTarget(pile, i, cutoff) {
  return +(pile[i] >= cutoff)
}

function getTransferStart(hand, cutoff) {
  let i = hand.length - 1
  const nextPile = getTarget(hand, i, cutoff)
  while (i > 0 && getTarget(hand, i - 1, cutoff) === nextPile) {
    --i
  }
  return [nextPile, i]
}

function shuffle(state) {
  const hand = state.hand
  const piles = state.piles
  if (hand) {
    const newPiles = state.newPiles
    if (hand.length) {
      const [nextPile, start] = getTransferStart(hand, state.cutoff)
      const transfer = hand.splice(start)
      newPiles[nextPile].push(...transfer)
      process.stdout.write(`${transfer.length} to ${pileLetters[nextPile]}`)
      return state
    }
    return shuffle({piles: [newPiles[0], [newPiles[1], piles]]})
  }
  if (piles) {
    const hand = piles[0]
    if (hand.every(
      (value, i) => {
	const next = i + 1
	return next >= hand.length || value === hand[next] - 1
      })) {
      process.stdout.write(
	`Pile of ${hand.length} cards is already shuffled.\n`,
      )
      return shuffle({piles: piles[1]})
    }
    console.log(iterString(map(listIter(piles), p => p.length)))
    return shuffle(
      {
	piles: piles[1],
	hand,
	cutoff: getCutoff(hand),
	newPiles: [[], []]
      },
    )
  }
  process.exit()
}

{
  const argv = process.argv.slice(2).map(Number)

  // The state may have piles, hand, cutoff, and newPiles.
  let state = shuffle({piles: [deck(argv[0], argv.slice(1))]})

  process.stdin.on(
    'close',
    () => {
      process.stdout.write('\n')
      process.exit()
    },
  )
  process.stdin.on(
    'readable',
    function() {
      if (this.read()) {
	state = shuffle(state)
      }
    },
  )
}
