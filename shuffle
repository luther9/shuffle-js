#!/usr/bin/env node

'use strict'

/*
A list is defined as either undefined or a 2-element Array where [1] is another
list.
*/

/*
  Return an iterator for the linked list.
*/
function* listIter(list) {
  while (list) {
    yield list[0]
    list = list[1]
  }
}

function* map(iter, func) {
  for (const item of iter) {
    yield func(item)
  }
}

/*
  Yield n items from iter. If iterator runs out of items, yield undefined.
*/
function* islice(iter, n) {
  for (let i = 0; i < n; ++i) {
    yield iter.next().value
  }
}

/*
Show all items in a string surrounded by parentheses.
*/
function iterToString(iter) {
  let str = '('
  let first = true
  for (const item of iter) {
    if (first) {
      first = false
    } else {
      str += ' '
    }
    str += item
  }
  return str + ')'
}

const pileLetters = ['A', 'B']

/*
Yield numbers from 0 to infinity.
*/
function* count() {
  for (let i = 0;; ++i) {
    yield i
  }
}

/*
Yield numbers in the range [0,n).
*/
function range(n) {
  return islice(count(), n)
}

// Yield numbers in [0,n) in a random order.
function* randomIntStream(n) {
  let pool = [...range(n)]
  while (pool.length) {
    const i = Math.floor(Math.random() * pool.length)
    yield pool[i]
    pool = pool.slice(0, i).concat(pool.slice(i + 1))
  }
}

function Streak(min, size=1) {
  return {min, size}
}

const StreakArrayProto = {
  get min() {
    return Math.min(...this.data.map(x => x.min))
  },

  get size() {
    return this.data.map(x => x.size).reduce((a, b) => a + b)
  },

  get length() {
    return this.data.length
  },

  get median() {
    return this.min + this.size / 2
  },

  concat(b) {
    if (b.length) {
      const lastI = this.data.length - 1
      const last = this.data[lastI]
      const next = b.data[0]
      return {
	__proto__: StreakArrayProto,
	data: last.min + last.size === next.min
	  ? this.data.slice(0, lastI)
	  .concat(Streak(last.min, last.size + next.size), b.data.slice(1))
	  : this.data.concat(b.data),
      }
    }
    return this
  },

  get(i) {
    return this.data[i]
  },

  slice(begin, end) {
    return {
      __proto__: StreakArrayProto,
      data: this.data.slice(begin, end),
    }
  },
}

/*
iter is an iterable of integers.
*/
function StreakArray(iter) {
  let data
  for (const n of iter) {
    if (data) {
      const lastIndex = data.length - 1
      const current = data[lastIndex]
      data = n === current.min + current.size
	? data.slice(0, lastIndex).concat(Streak(current.min, current.size + 1))
	: data.concat(Streak(n))
    } else {
      data = [Streak(n)]
    }
  }
  return {
    __proto__: StreakArrayProto,
    data: data || [],
  }
}

function deck(uniques, identicals) {
  const pool = randomIntStream(uniques + identicals.reduce((a, b) => a + b, 0))
  let d = [...islice(pool, uniques)]
  for (const n of identicals) {
    const more = [...islice(pool, n)]
    more.sort((a, b) => a - b)
    d = more.concat(d)
  }
  return StreakArray(d)
}

function getTarget(pile, i, median) {
  const streak = pile.get(i)
  const min = streak.min
  return min + streak.size - median <= median - min
}

function getTransferStart(hand, median) {
  const nextPile = getTarget(hand, 0, median)
  let i = 0
  for (; i < hand.length && getTarget(hand, i, median) === nextPile; ++i) {}
  return [nextPile, i]
}

function shuffle(state) {
  const hand = state.hand
  const piles = state.piles
  const median = state.median
  if (hand) {
    const newPiles = state.newPiles
    if (hand.length) {
      const [nextPile, end] = getTransferStart(hand, median)
      const transfer = hand.slice(0, end)
      process.stdout.write(`${transfer.size} to ${pileLetters[+nextPile]}`)
      return {
	piles,
	median,
	hand: hand.slice(end),
	newPiles: [
	  nextPile ? newPiles[0] : transfer.concat(newPiles[0]),
	  nextPile ? transfer.concat(newPiles[1]) : newPiles[1],
	],
      }
    }
    return shuffle({piles: [newPiles[0], [newPiles[1], piles]]})
  }
  if (piles) {
    const hand = piles[0]
    if (hand.length === 1) {
      console.log(`Pile of ${hand.size} cards is already shuffled.`,)
      return shuffle({piles: piles[1]})
    }
    console.log(iterToString(map(listIter(piles), p => p.size)))
    return shuffle(
      {
	piles: piles[1],
	hand,
	median: hand.median,
	newPiles: [StreakArray([]), StreakArray([])]
      },
    )
  }
  process.exit()
}

{
  const argv = process.argv.slice(2).map(Number)

  // The state may have piles, hand, median, and newPiles.
  let state = shuffle({piles: [deck(argv[0], argv.slice(1))]})

  process.stdin.on(
    'close',
    () => {
      process.stdout.write('\n')
      process.exit()
    },
  )

  process.stdin.on(
    'readable',
    function() {
      if (this.read()) {
	state = shuffle(state)
      }
    },
  )
}
